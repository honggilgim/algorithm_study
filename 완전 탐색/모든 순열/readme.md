# 완전 탐색 알고리즘

모든 경우의 수를 구하는 문제이다. 완전 탐색 알고리즘이 생각이 안나서 코딩테스트 하나를
망쳐서 공부해봤다. 완전 탐색의 중요 포인트는, bool 배열이라고 생각한다.

bool 배열

완전 탐색 알고리즘이라고 해서, 모두 탐색하지만은 안는다. 보통, bool 배열을 통해 한번 받은 값들은 다시 받지 않는다.

이 작동 방식을 위해서 bool 배열을 선언한다. visited 배열은, 완전 탐색 알고리즘으로 탐색한 경로가 다시 탐색되지 않도록 해준다.

그리고 나는, 재귀를 이용해 완전 탐색을 구현했는데 재귀를 이용할 경우, bool 배열이 flase와 true가 재귀 사이에 들어가있어야 한다.

```
		visited[i] = true;
		answer[count] = i;
		make(count + 1, answer);
		visited[i] = false;
```

실제 소스코드이다. 저런 식으로, 완전 탐색으로 true로 바꿔준 이후, 재귀에 들어가고 그 이후에 바로 false로 바꿔준다.

예전에 처음 공부했을 때는 매우 헷갈렸던 개념이지만 재귀를 통해 다시 함수의 반복문으로 들어간다고 생각하면 쉽다.

완전 탐색 문제를 더 풀어봐야겠다.

# 다른 사람의 코드

이 문제는 완전 탐색의 기본 문제다. 그래서 공부할게 많아 보여 다른 사람의 코드를 봤는데... 어려운 코드들이 너무 많다. 하지만 좋은 함수를 하나 알았다.
algorithm 태그의,
```
	do{

		for(int i=0; i<N; i++){
			cout << v[i] << " ";
		}

		cout << '\n';

	}while(next_permutation(v.begin(),v.end()));
```

next_permutation 함수인데, 저렇게 넣어주면 순열을 출력해준다. 원하는 순열을 그대로 뽑아낼 수 있다.
출력은, 1부터 N까지 1부터 나오며 뽑아준다.

```
	do{

		for(int i=0; i<4; i++){
			cout << v[i] << " ";
		}

		cout << '\n';

	}while(prev_permutation(v.begin(),v.end()));
```
똑같은 prev_permutation 함수인데, 함수를 앞에서부터 원하는 순열로 뽑아준다. 
출력은 반대로 N부터 1까지 N으로 뽑아준다.
