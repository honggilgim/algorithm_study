# 그래프 탐색 + 브루트 포스 알고리즘

이제는 나름 익숙해진 bfs와 브루트 포스 알고리즘이 결합한 문제다. 브루트 포스를 통해 모든 경우의 수를 검사하고 벽이 세워진 경우 bfs를 통해 문제를 해결한다.

이 문제를 풀 때, 어려웠던 점이 몇가지 있다.

1. map 배열을 3개 만들어놓은 이유

첫 배열은 복사용으로 놔두고, 두번째 배열은 벽이 1개 세워진 상태에서 벽을 만드는 함수에 들어간 모습이다. 그리고 3번째 배열은, 벽이 모두 세워진 배열이다. 두 번째 배열에서 벽이 세워지는 모습이 분화하기에,
이 두번째 배열을 그대로 bfs로 돌리면 오류가 난다. 그래서 3개의 배열을 만들어서 bfs를 돌렸다. (이건 2개일 때 무언가 오류가 있었던 것 같다..)

2. 벽 3개 세우기

bfs는 이제 익숙해졌기에 손쉽게 구현했지만, 벽 3개 세우는 과정 구현하는게 생각보다 많이 어려웠다. 브루트 포스 알고리즘을 써야 된다는 사실도 처음에는 솔직히 몰랐고 힌트를 보고나서야 알았다.
그리고 코드를 보면 테스트를 위해서 출력해논 코드가 많은데, bfs는 잘 되는지 반복횟수가 이게 맞는지 테스트했다.

예제를 계산기를 돌려서 3개를 뽑는 경우의 수와, 내가 bfs를 돌린 경우의 수가 맞을 때까지 테스트했다. 결론적으로는 맞아서 넣어봤더니, 정답이 나왔다.

이 두가지가 너무 헷갈려서 시간을 많이 잡아먹었다.

그리고, 테스트 케이스를 돌렸을때 출력하니 시간이 너무 오래걸렸다. 모든 수행과정을 cout로 출력해봤는데 시간이 오래걸렸다. 그래서 시간초과 날 줄 알고 제출을 안했었는데, 출력함수 문제였다.

# 문제풀이

브루트 포스 알고리즘과, 그래프 탐색이 더해진 문제다. 이 두가지 중 하나라도 부족하면, 문제를 풀기 많이 어려워진다. 나는 브루트 포스 알고리즘이 익숙치 않아서 문제풀이에 많은 시간이 소요됬다.

결론적으로는 성공했고 다시 브루트 포스 알고리즘을 제대로 숙지했지만, 부족하다는 점을 느꼇다. 하지만 반대로 말하면 이 두가지만 더하면 쉽게 문제를 해결할 수 있다.

# 다른 사람의 풀이

이 문제는, 푸는 방법도 정말 제각각이었던 문제였다.

그리고 내 코드의 가장 큰 문제점은, 역시 배열을 3개 이용한 거다. 배열을 2개 이용한 코드들이 제일 많았다.

문제풀이를 찾아보며 공부하다가 다른 사람의 블로그에 아주 정리가 잘 되어있는 모습을 발견했다.

https://salon.tistory.com/m/73

이 사이트에 아주 잘 정리되어 있다. 다른 사람들의 풀이를 정리해서 올려놓은 분이다. 나는 2번째 케이스이다.
