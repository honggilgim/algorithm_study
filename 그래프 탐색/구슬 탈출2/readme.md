# 문제 풀이

그래프 탐색으로 풀어주면 된다. 알고리즘 자체는 쉽지만, 걸려있는 조건이 많고 평범한 그래프 탐색으로는 절대 풀 수 없는 문제다.

bfs를 사용하여 풀었는데, 최소 거리를 구하는 일에는 bfs가 적격이라 생각해서 이를 이용했다.

이 문제는 평소에 자주 사용하는 pair를 사용한 queue로는 해결이 매우 힘들다. 들어가는 인자가 빨간 공, 파란 공의 4개의 인자에 count해주어야 하는 값까지 총 다섯개가 들어가기에,

```
struct ballindex
{
	int rx;
	int ry;
	int bx;
	int by;
	int cot;
};
```

로 구조체를 선언해서 풀었다.

이 문제에 생각해야 되는 조건은 여러가지다. 일단, 파란 공이 구멍에 빠지면 안된다. 그렇기에
```
if (map[bbx][bby] == "O") continue;
```
이 구문으로 파란 공이 빠지지 않게 했다.
그리고 가장 어려운 조건이었는데, 파란 공과 빨간 공은 겹칠 수 없다. 이것은,
```
			if (rrx == bbx && rry == bby)
			{
				if (redmove > bluemove)
				{
					rrx -= dx[i];
					rry -= dy[i];
				}
				else
				{
					bbx -= dx[i];
					bby -= dy[i];
				}
			}
```
이 구문을 사용해서 겹치지 않게 했다. 겹칠 경우, 빨간 공의 움직인 거리와 파란 공의 움직인 거리를 비교해서 더 많은 거리를 움직인 쪽에게 움직인 방향으로1만큼 빼 주었다.

이 문제는 조건 검사만큼 움직임을 만드는 일이 중요한데, 처음에는 오른쪽, 왼쪽, 위쪽, 아래쪽을 전부 생각해서 하나하나 썼는데 너무 안되서 그냥 합쳤다.
```
int ball(int& x, int& y, int i)
{
	int count = 1;
	while ((map[x + dx[i]][y + dy[i]] != "#") && (map[x][y] != "O"))
	{
		x += dx[i];
		y += dy[i];
		count++;
	}
	return count;
}
```

공의 움직임을 만드는 함수다. 이건 친구에게 힌트를 받아서 이렇게 작성했다. 인자에 &를 넣어준 이유는, 공의 움직임이 다른 함수의 인자에 전달되게 하기 위해서 그랬다.

리턴값으로 카운트를 반환해주는데, 이 카운트는 공의 움직인 거리를 말한다. 이 카운트로 빨간 공과 파란 공 누가 더 많이 움직였는지 판별한다.

공이 움직일 수 있는 조건은, 주어진 방향대로이고 맵에서 다음에 움직일 거리가 #이 아닌 것과, 위치하고 있는 위치가 구멍일 경우에는 안된다는 조건을 걸었다.

# 다른 사람의 코드

다 쓴 사람도 있고 나처럼 반복문으로 작성한 사람도 있다. 대게 비슷한 알고리즘으로 작성했다.

# 문제 후기

최근에 푼 문제 중 가장 어려운 문제였다. 이 문제를 해결하기까지, 총 4일 걸렸다. 인턴 활동중이기에 시간을 많이 할당할 수 없음은 둘째치고,

조건이 너무 많아서 구현이 어려웠다. 그리고 조건 자체도 매우 헷갈렸다.

