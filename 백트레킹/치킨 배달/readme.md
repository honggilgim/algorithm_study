# 문제풀이 방법

주어진 거리에 존재하는 치킨 집 중 M개를 골라 주변 집들과 최소의 거리를 가지는 치킨집을 고르는 문제다.

문제의 해결 방법은,

+ 치킨집을 선택한다.

+ 집을 선택한 후, 치킨집과의 거리를 구한다.

라는 2가지의 심플한 과정으로 이루어진다.

치킨집을 선택하기 위해, 치킨집이 나오면 chicken 이라는 vector에 push 해주고, 집 역시 집이 나오면 푸쉬해주었다.

그리고 choice 함수에 들어가는데, choice 함수는 원하는 치킨집의 수가 나올때까지 순열을 구한다. 순열을 구할 때는, 재귀를 통해 구했다.

그리고 치킨집이 원하는 갯수에 맞으면, 거리를 구한다. 그리고 최소 거리를 구해서 출력해주는 문제다.

## 문제풀면서 어려웠던 점

시간초과가 엄청나게 떴다. 첫 코드에서는 모든 순열을 구해 그 순열로 치킨집의 거리를 구했기 때문에, 시간초과가 나왔다. 그리고 치킨집이 M이 되도 return 을 안해줘서 오래 걸렸다.

이게 내 첫번째 실수 return 을 안 써준 일.

그래서 return을 써주고, 이제는 맞을 줄 알았다.

그런데 또 시간초과가 떴다.

시간초과를 해결하기 위해 코드를 분석하고, 열심히 알아봤다. 결과적으로,

```
if (chicken.size() - i < M - a) return;
```

이 코드와

```
// 원래 반복문
for (int i = 0; i < chicken.size(); i++)

// 변형된 반복문
for (int i = a; i < chicken.size(); i++)
```

으로 바꾸어서, 시간을 엄청나게 줄일 수 있었다. a가 되는 이유는, 어차피 a+1로 함수에 들어가니 굳이 0부터 반복문을 다시 시작할 필요가 없다.

즉, 0부터 시작하면 처음부터 수를 찾기에 a부터 시작해 그 전의 수가 반복되는 일을 줄여주는 거다. 이 방법을 통해 획기적으로 시간 복잡도를 줄일 수 있었다.

그래서 결과적으로 성공했다.

## 다른 사람의 코드

다른 사람들 역시 나랑 비슷하게 풀었다. 저 두 가지 개념이 시간초과를 잡는 핵심이라고 생각한다. 그리고, 시간초과가 나면, 꼭! 변수를 전역으로 선언해서 변수 선언 횟수를 줄여주어야겠다.
