# 문제해결법

구현 문제가 늘 그렇듯, 어려운 알고리즘이나 알아야 할 풀이 없이 내가 아는 것들을 조합해서 풀었다. 문제를 풀던 도중, 의문점이 생겼는데, if문의 continue가 작동되는 문제였다.

아직 문제는 제대로 해결하지 못했지만, 구현에 성공했다. 문제 풀이 자체는 주어진 것들을 따라가면 쉽게 풀 수 있었다. 아주 어려운 문제는 아니고, 적당히 어려운 구현 문제였다.

문제풀이는,

주어진 조건인 윗 면을 1로 두고, 동쪽을 바라보는 방향이 3인 상태로 놓여있다는 점에서부터 시작된다. 그리고 모든 주사위는 0 이다.

그렇게 되면, 주사위의 배열의 순서는 위, 아래, 동, 서, 남, 북 이렇게 구성된다.

이렇게 구현된다는 사실을 깨닫고 나면, 어떻게 움직이던 주사위를 위 아래 동 서 남 북에 맞춰 재조합 할 수 있다.

이 점을 착안하자 문제가 아주 쉽게 풀렸다. 일단, 안 되는 조건을 먼저 체크한다.

이곳에서 안 되는 조건은 범위를 벗어나는 일인데 이에 맞춰 조건을 구성한다. 예를 들면, y = m-1(y값이 경계값 전) 이고 a = 1(y가 더해지는 이동방향 즉 동쪽)으로 이동할 경우에는 다음으로 넘어가야 한다.

그리고 앞서 말한 조건에 맞춰 코드를 구현한다면 범위를 벗어났는지 체크하는 일이 필요가 없어진다. 어차피 그 전에 걸러지기 때문이다.

```cpp
int check(int a)
{
	if (a == 1 && y == m - 1) return 0;
	else if (a == 2 && y == 0) return 0;
	else if (a == 3 && x == 0) return 0;
	else if (a == 4 && x == n - 1) return 0;
	return 1;
}
```

조건을 검사하는 함수다. 원래는 원래 코드의 if문 안에 넣었는데, continue에 이상이 생겼는지 자꾸만 cout는 작동하지 않지만 x,y값에 변화가 생겼다.

이 점을 해결하기 위해 앞쪽에 if문을 조건에 맞춰 놓아줬지만, 그래도 continue를 했음에도 변수값에 변화가 생겼다. 그래서 그냥 값의 가능여부를 판단하는 함수를 만들어 놓고, 그 함수에 맞춰 바꾸었다.

그렇게 된 결과 잘 작동하는 지금의 모습을 얻을 수 있었다.
